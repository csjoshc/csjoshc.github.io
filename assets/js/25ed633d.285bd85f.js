"use strict";(self.webpackChunkdocusaurus_temp=self.webpackChunkdocusaurus_temp||[]).push([[3615],{3828:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"Python/IntroCompThinkDataSci/unit1/unit1","title":"unit1","description":"\ud83c\udfe0 Home","source":"@site/docs/Python/IntroCompThinkDataSci/unit1/unit1.md","sourceDirName":"Python/IntroCompThinkDataSci/unit1","slug":"/Python/IntroCompThinkDataSci/unit1/","permalink":"/docs/Python/IntroCompThinkDataSci/unit1/","draft":false,"unlisted":false,"editUrl":"https://github.com/csjoshc/csjoshc.github.io/tree/main/docs/Python/IntroCompThinkDataSci/unit1/unit1.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"virtenv_jupyter_nb","permalink":"/docs/Python/General/virtenv_jupyter_nb"},"next":{"title":"problemset1","permalink":"/docs/Python/IntroCompThinkDataSci/unit1/problemset1"}}');var s=n(4848),a=n(8453);const r={},o="Optimization models & the Knapsack problem",l={},h=[{value:"Knapsack problem",id:"knapsack-problem",level:2},{value:"Brute force algorithm",id:"brute-force-algorithm",level:2},{value:"Greedy algorithm",id:"greedy-algorithm",level:2},{value:"Recursive Fibonacci",id:"recursive-fibonacci",level:2},{value:"Memoization - Dynamic Programming",id:"memoization---dynamic-programming",level:2},{value:"Dynamic Programming",id:"dynamic-programming",level:2},{value:"Roads and graph theory",id:"roads-and-graph-theory",level:2},{value:"Class Graph",id:"class-graph",level:2},{value:"Exercise 3 - three students in a line",id:"exercise-3---three-students-in-a-line",level:2},{value:"Finding the shortest path",id:"finding-the-shortest-path",level:2}];function d(e){const t={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"\ud83c\udfe0 Home\n\ud83d\udc0d Python"}),"\n",(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"optimization-models--the-knapsack-problem",children:"Optimization models & the Knapsack problem"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Objective function to maximize or minimize"}),"\n",(0,s.jsx)(t.li,{children:"Constraints"}),"\n",(0,s.jsx)(t.li,{children:"Often just approximate a solution with a greedy algorithm"}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"knapsack-problem",children:"Knapsack problem"}),"\n",(0,s.jsx)(t.p,{children:"In the knapsack problem, you have a capacity and have to decide how to fill it. Discrete contents are harder than continuous ones."}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Each item is a pair of value and weight"}),"\n",(0,s.jsxs)(t.li,{children:["Knapsack has a total capacity, ",(0,s.jsx)(t.em,{children:"w"})]}),"\n",(0,s.jsx)(t.li,{children:"A set of available items"}),"\n",(0,s.jsx)(t.li,{children:"A list indicating whether an item has already been taken"}),"\n",(0,s.jsx)(t.li,{children:"For each item in available items, choose those to take and multiply it by its value."}),"\n",(0,s.jsxs)(t.li,{children:["The sum of chosen items' weights is less than ",(0,s.jsx)(t.em,{children:"w"})]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"brute-force-algorithm",children:"Brute force algorithm"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Try every possible combination (every subset of subject set), remove those not under ",(0,s.jsx)(t.em,{children:"w"}),", and choose the remaining with highest value.","\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"The algorithm is exponential, having 2^n complexity"}),"\n",(0,s.jsx)(t.li,{children:"Find approximate and optimal solutions"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"greedy-algorithm",children:"Greedy algorithm"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"while the knapsack is not full, put the best available item in."}),"\n",(0,s.jsx)(t.li,{children:"nlog(n) complexity\nWhat does 'best' mean? Based on the highest value, lowest weight, or the ratio?"}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'def greedy(items, maxCost, keyFunction):\n    """Assumes items a list, maxCost >= 0,\n         keyFunction maps elements of items to numbers"""\n    itemsCopy = sorted(items, key = keyFunction,\n                       reverse = True)\n    result = []\n    totalValue, totalCost = 0.0, 0.0\n    for i in range(len(itemsCopy)):\n        if (totalCost+itemsCopy[i].getCost())  avail:\n    # Explore right branch only\n    result = maxVal(toConsider[1:], avail)\nelse:\n    nextItem = toConsider[0]\n    # Explore left branch\n    withVal, withToTake = maxVal(toConsider[1:], avail - nextItem.getCost())\n    withVal += nextItem.getValue()\n    # Explore right branch\n    withoutVal, withoutToTake = maxVal(toConsider[1:], avail)\n    # Explore better branch\n    if withVal > withoutVal:\n        result = (withVal, withToTake + (nextItem,))\n    else:\n        result = (withoutVal, withoutToTake)\n\n'})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Consider the first item - if it exceeds the available space, recursively call itself to consider the rest of thelist"}),"\n",(0,s.jsxs)(t.li,{children:["Else - consider the cases where the item is ",(0,s.jsx)(t.strong,{children:"taken"})," or ",(0,s.jsx)(t.strong,{children:"not taken"}),"; in both cases the item is ",(0,s.jsx)(t.strong,{children:"removed"})," from the items to take (",(0,s.jsx)(t.code,{children:"toConsider[1:]"}),")."]}),"\n",(0,s.jsxs)(t.li,{children:["If the item is ",(0,s.jsx)(t.strong,{children:"taken"}),", then call the function recursively with the avaiable space minus that of the taken item (",(0,s.jsx)(t.code,{children:"avail - nextItem.getUnits()"}),")."]}),"\n",(0,s.jsxs)(t.li,{children:["If the item is ",(0,s.jsx)(t.strong,{children:"not taken"}),", call the function recursively with the same available space, ",(0,s.jsx)(t.code,{children:"avail"}),"."]}),"\n",(0,s.jsx)(t.li,{children:"Finally, evaluate both branches for the better outcome."}),"\n",(0,s.jsxs)(t.li,{children:["Return ",(0,s.jsx)(t.code,{children:"result"}),", a tuple of the value in a set, and a list of the items in a set. This is the best solution thus far."]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"recursive-fibonacci",children:"Recursive Fibonacci"}),"\n",(0,s.jsx)(t.p,{children:"The below implementation is simple but impossible to run for moderately sized numbers due to how inefficient it is, since the number of function calls is basically related to the growth in fibonacci value itself. For example fib(120) is about 8.7E24."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:"def fib(n):\n    if n == 0 or n == 1:\n        return 1\n    else:\n        return fib(n - 1) + fib(n - 2)\n"})}),"\n",(0,s.jsx)(t.h2,{id:"memoization---dynamic-programming",children:"Memoization - Dynamic Programming"}),"\n",(0,s.jsx)(t.p,{children:"When repeating function calls for identical inputs, lookup the output value in a previously recorded table instead of recalculating it. If it hasn't been calculated yet, calculate it and add it to the table."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:"def fastFib(n, memo = {}):\n    if n == 0 or n == 1:\n        return 1\n    # return the value at key in memo if n != 0,1\n    try:\n        return memo[n]\n    # calculate new value and store in memo dict if unknown\n    except KeyError:\n        result = fastFib(n - 1, memo) + fastFib(n - 2, memo)\n        memo[n] = result\n\n"})}),"\n",(0,s.jsx)(t.p,{children:"Dynamic programming criteria:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Optimal Substructure"})," - locally optimal solutions can be comebined for globally optimal solutions"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Overlapping subproblems"})," - identical subproblems use identical solutions"]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"dynamic-programming",children:"Dynamic Programming"}),"\n",(0,s.jsx)(t.p,{children:"For a bag problem, subproblems can be made to be overlapping by generalizing the problem to be solved as a function of remaining weight and the weight of taken items, regardless of the specific items taken. For example, two subproblems would overlap if the occupied weight and available items to choose from were identical, even if the items chosen so far were different.\nIn defining a specific subproblem, pass a dictionary of previously encountered subproblems and optimal solutions: The key is a tuple of items left to be considered (length of the item list since items are removed after being considered) and the remaining weight.\nOverall, dynamic programming runs on low order polynomial in a best case scenario, and can be much, much faster than a comparable exponential algorithm."}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"solve problems with exponential solution space"}),"\n",(0,s.jsx)(t.li,{children:"find optimal solutions, not just approximate ones"}),"\n",(0,s.jsx)(t.li,{children:"reduce sorting order below nlogn from merge sort"}),"\n",(0,s.jsx)(t.li,{children:"Example: choosing step sizes (1, 2) for N steps to traverse is a problem with optimal substructure and overlapping subproblems."}),"\n"]}),"\n",(0,s.jsx)(t.h1,{id:"graph-problems",children:"Graph Problems"}),"\n",(0,s.jsxs)(t.p,{children:["A graph is a set of nodes/vertices that may have properties associated with them (color in this example). The edges/arcs connecting pairs of nodes can be undirected or directed (with parent and child nodes), and unweighted or weighed. This example is of a graph with directed, weighted edges.\n",(0,s.jsx)(t.img,{src:n(4350).A+"",width:"702",height:"347"}),"\nA tree is a special case of a graph. Networks in general can be represented by graphs. In these networks, note attributes can include the color, size and label of the node."]}),"\n",(0,s.jsx)(t.h2,{id:"roads-and-graph-theory",children:"Roads and graph theory"}),"\n",(0,s.jsx)(t.p,{children:"A good example of real world application is modeling travel distance between two locations, with those locations and other intermediate locations modeled as nodes, and the distance between modeled as edges. Each edge has a weight representing the source to destination travel time. Then, the ideal travel time would be the solution of a graph optimization problem.\nFor this class of problems more generally, graphs allow the abstraction away of irrelevant details."}),"\n",(0,s.jsx)(t.h2,{id:"class-graph",children:"Class Graph"}),"\n",(0,s.jsx)(t.p,{children:"There are a few classes implemented, and I'll just summarize them each here"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"Node"}),' - only has a "Name" attribute']}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"Edge"})," - constructor has source, dest attributes assumed to be of class Node"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"Digraph"})," - constructor takes no arguments, but has an edges attribute that is initialized empty, a dictionary mapping each of its Node attributes to one or more of its other Node attrributes. The primary helper functions include those adding Nodes, Edges and also a decorator to define the conversion to a string when printing the object. Other helper functions are for accessing and returning Node attributes."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"Graph"})," - a subclass of Digraph with a ",(0,s.jsx)(t.code,{children:"addEdge()"})," method that overrides the parent class method by adding an additional reversed edge to the edges dictionary attribute.\nThe edges attribute of Class Digraph is an adjacency list, associating each node with a list of child nodes.\nWhen representing graphs, phenomena such as loops can arise, which complicates the optimization search."]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"exercise-3---three-students-in-a-line",children:"Exercise 3 - three students in a line"}),"\n",(0,s.jsx)(t.p,{children:"Combination of three students (ordered line) are represented by nodes. Two nodes are connected by an edge if the ordered lines are interchangeable by just switching one pair of adjacent students.\nThe way the addEdge method is implemented for Graph class, the node must be in the edges attribute first before an edge can be added."}),"\n",(0,s.jsx)(t.h2,{id:"finding-the-shortest-path",children:"Finding the shortest path"}),"\n",(0,s.jsx)(t.p,{children:"The depth first search is similar to the left first search of a bag problem. The main difference is keeping track of previously traversed nodes, since there can be loops in the graph. Also:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"return to most recent node once a node with no children is reached"}),"\n",(0,s.jsx)(t.li,{children:"discard paths not shorter than the current shortest path"}),"\n",(0,s.jsxs)(t.li,{children:["recursively find the DFS on child nodes not in the current path.\nThe breadth first search is somewhat more complex because it is searching across all nodes simultaneously, and thus needs to keep track of the depth of its search as it goes. It generates paths in a branching fashion - all child nodes of the current path are simultaneously generated and appended to a pathqueue. The oldest item in the pathqueue is removed and its child nodes are appended to it, and then added back to the pathqueue. As soon as a path is found, the algorithm stops - this works because all the path lengths in pathqueue increment in length together - therefore the first found path ",(0,s.jsx)(t.strong,{children:"must"})," be the shortest.\nBFS isn't modifiable for use in a weighted path search. It is of O(n) complexity."]}),"\n",(0,s.jsx)(t.li,{children:"may run slower or faster than DFS"}),"\n",(0,s.jsx)(t.li,{children:"if it prioritizes the same nodes, will be as fast as DFS in\nGraph problems are in some sense already solved with many algorithms - what is complex is fitting real world situations into the framework of graphs.\nLast exercise - when defining a child class with its own constructor (not just its own methods), I needed to redefine all the attribute assignment, there should be a way to use the superclass constructor and just set the additional attributes"}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:"class WeightedEdge(Edge):\n    def __init__(self, src, dest, weight):\n        self.src = src\n        self.dest = dest\n        self.weight = weight\n    def getWeight(self):\n        return self.weight\n    def __str__(self):\n        return self.src.getName() + '->' + self.dest.getName() + ' (' + str(self.getWeight()) + ')'\n"})})]})}function c(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},4350:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/screenshot2-e7e17427732cd3c7622d62aa2030fa61.png"},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var i=n(6540);const s={},a=i.createContext(s);function r(e){const t=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);