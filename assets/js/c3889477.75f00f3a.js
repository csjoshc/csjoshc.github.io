"use strict";(self.webpackChunkdocusaurus_temp=self.webpackChunkdocusaurus_temp||[]).push([[356],{1426:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>l,default:()=>p,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"Python/IntroCompThinkDataSci/unit1/problemset1","title":"problemset1","description":"\ud83c\udfe0 Home","source":"@site/docs/Python/IntroCompThinkDataSci/unit1/problemset1.md","sourceDirName":"Python/IntroCompThinkDataSci/unit1","slug":"/Python/IntroCompThinkDataSci/unit1/problemset1","permalink":"/docs/Python/IntroCompThinkDataSci/unit1/problemset1","draft":false,"unlisted":false,"editUrl":"https://github.com/csjoshc/csjoshc.github.io/tree/main/docs/Python/IntroCompThinkDataSci/unit1/problemset1.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"unit1","permalink":"/docs/Python/IntroCompThinkDataSci/unit1/"},"next":{"title":"plotting","permalink":"/docs/Python/IntroCompThinkDataSci/unit2/plotting"}}');var o=n(4848),r=n(8453);const s={},l="Planning for problem set 1",a={},c=[{value:"Overview",id:"overview",level:2},{value:"Problem 1 - Greedy Cow Transport",id:"problem-1---greedy-cow-transport",level:2},{value:"Solution for problem 1",id:"solution-for-problem-1",level:3},{value:"Solution for Problem 3",id:"solution-for-problem-3",level:3}];function h(e){const t={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"\ud83c\udfe0 Home\n\ud83d\udc0d Python"}),"\n",(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"planning-for-problem-set-1",children:"Planning for problem set 1"})}),"\n",(0,o.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsx)(t.p,{children:"A problem of selecting items (Cows) to fit in a bag based on the 'space' available\nEach possible cow has a name and a space consumption associated with it:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"Maggie,3\nHerman,7\nBetsy,9\nOreo,6\nMoo Moo,3\nMilkshake,2\nMillie,5\nLola,2\nFlorence,2\nHenrietta,9\n"})}),"\n",(0,o.jsx)(t.h2,{id:"problem-1---greedy-cow-transport",children:"Problem 1 - Greedy Cow Transport"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"pick the heaviest cow first"}),"\n",(0,o.jsxs)(t.li,{children:["don't mutate the dictionary that is passed in - make a ",(0,o.jsx)(t.code,{children:".copy()"})," of that dictionary?"]}),"\n",(0,o.jsx)(t.li,{children:"Order doesn't matter, break same weight ties arbitrarily, unique names\nExample: Running the function with two parameters: a list of cows to transport, and the weight limit per trip"}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:'`{"Jesse": 6, "Maybel": 3, "Callie": 2, "Maggie": 5}, 10`\n'})}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:'`[["Jesse", "Maybel"], ["Maggie", "Callie"]]`\n'})}),"\n",(0,o.jsx)(t.p,{children:"Some thoughts: The algorithm always chooses the HEAVIEST cow first. This means that we sometimes get nonoptimal solutions, such as the fact with a weight limit of 10 you could'vce fit 3 cows in the first trip (5, 3, and 2 units) if you had avoided choosing weight 6 first."}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"While there are cows left to transport:"}),"\n",(0,o.jsx)(t.li,{children:"While there is space in the current trip"}),"\n",(0,o.jsx)(t.li,{children:"Choose the heaviest cow and add it"}),"\n",(0,o.jsx)(t.li,{children:"If there is no space, begin a new trip\nI think I'll try implementing this as nested loops before trying recursion"}),"\n"]}),"\n",(0,o.jsx)(t.h3,{id:"solution-for-problem-1",children:"Solution for problem 1"}),"\n",(0,o.jsx)(t.p,{children:"Spoilers below.\nMy way of dealing with dictionaries and finding the correct key to append to the trip list was a little crude, but it works overall."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-python",children:'def greedy_cow_transport(cows,limit=10):\n    cowsleft = cows.copy()\n    triplist = []\n    index = 0\n    while len(cowsleft) != 0:\n        space = limit\n        triplist.append([])\n        while len(cowsleft) != 0 and space >= cowsleft[min(cowsleft, key=cowsleft.get)]:\n        # filling a trip can empty the remaining cow list - need to prevent ValueError when trying to find min of empty dict\n            # While there is space for the smallest cow, try putting in all the cows\n            keys = []\n            weight = max(v for k, v in cowsleft.items() if v  limit:\n                # break out of current set parition (for trip in item)\n                # print("Is greater:", trip, tripweight, limit)\n                #print("Breaking on trip:", trip, tripweight)\n                fits = False\n\n        #print(item, "break", fits)\n        # if "fits" flag is True, that means all trips were tested and were not broken out of because of excessive weight\n        # therefore we can use it to trigger a return for the current item\n\n        if fits:\n\n'})}),"\n",(0,o.jsx)(t.h1,{id:"problem-3---compare-the-algorithms",children:"Problem 3 - Compare the algorithms"}),"\n",(0,o.jsxs)(t.p,{children:["The brute force algorithm takes 6800 times as long the way I implemented it. It is guaranteed to give the optimal solution, while the greedy one ",(0,o.jsx)(t.em,{children:"may"})," or ",(0,o.jsx)(t.em,{children:"may not"})," arrive at the optimal solution."]}),"\n",(0,o.jsx)(t.h3,{id:"solution-for-problem-3",children:"Solution for Problem 3"}),"\n",(0,o.jsx)(t.p,{children:"Spoilers below. This was a quick and dirty snippet to answer the multiple choice questions since they didn't actually need ask for code for the grader for problem 3."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-python",children:"start = time.time()\nprint(greedy_cow_transport(cows, 10))\nend = time.time()\nprint(end - start)\nstart1 = time.time()\nprint(brute_force_cow_transport(cows, 10))\nend1 = time.time()\nprint(end1 - start1)\n[['Betsy'], ['Henrietta'], ['Herman', 'Maggie'], ['Oreo', 'Moo Moo'], ['Millie', 'Milkshake', 'Lola'], ['Florence']]\n0.00010728836059570312\n[['Henrietta'], ['Betsy'], ['Florence', 'Millie', 'Maggie'], ['Moo Moo', 'Herman'], ['Milkshake', 'Oreo', 'Lola']]\n0.7299518585205078\n"})})]})}function p(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>l});var i=n(6540);const o={},r=i.createContext(o);function s(e){const t=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);