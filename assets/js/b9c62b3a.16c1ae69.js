"use strict";(self.webpackChunkdocusaurus_temp=self.webpackChunkdocusaurus_temp||[]).push([[9623],{673:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>l,frontMatter:()=>s,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"Github/intro_gh","title":"intro_gh","description":"\ud83c\udfe0 Home","source":"@site/docs/Github/intro_gh.md","sourceDirName":"Github","slug":"/Github/intro_gh","permalink":"/docs/Github/intro_gh","draft":false,"unlisted":false,"editUrl":"https://github.com/csjoshc/csjoshc.github.io/tree/main/docs/Github/intro_gh.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"webdev2019","permalink":"/docs/General/webdev2019"},"next":{"title":"intro_gh","permalink":"/docs/Github/intro_gh"}}');var o=n(4848),r=n(8453);const s={},a="Introduction to Git and GitHub",c={},d=[{value:"Updating an existing repository",id:"updating-an-existing-repository",level:2},{value:"Adding from remote",id:"adding-from-remote",level:2},{value:"git checkout",id:"git-checkout",level:2},{value:"Formatting",id:"formatting",level:2},{value:"Compiling .md to html using task build in vscode",id:"compiling-md-to-html-using-task-build-in-vscode",level:2}];function h(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"\ud83c\udfe0 Home\n\ud83d\udc19 Github"}),"\n",(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"introduction-to-git-and-github",children:"Introduction to Git and GitHub"})}),"\n",(0,o.jsx)(t.h1,{id:"intro-to-using-github",children:"Intro to using Github"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"create new respository on github"}),"\n",(0,o.jsx)(t.li,{children:"create new folder under Notebooks"}),"\n",(0,o.jsx)(t.li,{children:"change data directory in vscode"}),"\n",(0,o.jsx)(t.li,{children:"create sample note md files"}),"\n",(0,o.jsxs)(t.li,{children:["follow directions on ",(0,o.jsx)(t.a,{href:"https://help.github.com/en/articles/adding-an-existing-project-to-github-using-the-command-line",children:"this"})," link"]}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:'# in console, cd to folder above\n\ngit add.\ngit commit -m "First commit"\n# Then, **copy** the git url\n\ngit remote -v\n\n'})}),"\n",(0,o.jsx)(t.h2,{id:"updating-an-existing-repository",children:"Updating an existing repository"}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"cd /../../media/jcmint/'Data Volume'/csjoshc.github.io "}),"\nI was having a lot of trouble managing the staging, commit and push to branch process. ",(0,o.jsx)(t.a,{href:"https://product.hubspot.com/blog/git-and-github-tutorial-for-beginners",children:"This"})," ",(0,o.jsx)(t.em,{children:"maybe"})," cleared it up for me.\n",(0,o.jsx)(t.strong,{children:"As a summary"}),", after any file change you want to eventually push, you must do"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:'git add .\n\ngit commit -a -m "new change"\n\n'})}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"the first and third must be used together after any change"}),".\n",(0,o.jsx)(t.code,{children:"git add ."})," stages the current version of a file, or the current version of all the files. Therefore, this needs to be run after all changes you are intending to package together are made.\n",(0,o.jsx)(t.code,{children:"git status"})," good to run after git add. This will make sure you are committing what you think you are. ",(0,o.jsx)(t.code,{children:"git commit"})," adds those changes to the index of changes to be sent off, and ",(0,o.jsx)(t.code,{children:"git push origin master"})," is fine when working on own repository\n",(0,o.jsx)(t.code,{children:"git push origin v1 "})," - When pushing to branch"]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"adding -u as an argument is questionable"}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"adding-from-remote",children:"Adding from remote"}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"git clone repo.url"}),"\nurl = ",(0,o.jsx)(t.a,{href:"mailto:git@github.com",children:"git@github.com"}),":csjoshc","/csjoshc.github.io.git"]}),"\n",(0,o.jsx)(t.h2,{id:"git-checkout",children:"git checkout"}),"\n",(0,o.jsx)(t.p,{children:"This creates a new branch for tracking code changes that won't affect the state of the master or other branch (so you could switch back to that branch and push that branch as a separate project state from the new branch). At least that's how I understand it. This might not be that necessary, since I don't really have a dev vs production version of my notes."}),"\n",(0,o.jsx)(t.h2,{id:"formatting",children:"Formatting"}),"\n",(0,o.jsxs)(t.p,{children:["Now using ",(0,o.jsx)(t.a,{href:"https://gist.github.com/tuzz/3331384",children:"premade css"})," in a folder in the root directory."]}),"\n",(0,o.jsx)(t.h2,{id:"compiling-md-to-html-using-task-build-in-vscode",children:"Compiling .md to html using task build in vscode"}),"\n",(0,o.jsx)(t.p,{children:"Important step even though process isn't automated. Since I'm not changing too many .md too frequently, ctrl-shift-b and Build Task is ok.\ntasks.json:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:'"command": "markdown-it",\n"args": [\n    "${relativeFile}",\n    "-o",\n    "${fileDirname}/${fileBasenameNoExtension}.md"\n],\n'})})]})}function l(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>a});var i=n(6540);const o={},r=i.createContext(o);function s(e){const t=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);